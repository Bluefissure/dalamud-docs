# 逆向工程（针对插件开发人员）

逆向工程一个应用程序是困难的。逆向工程像《最终幻想 XIV》这样的大型游戏则更加困难
。有很多移动的部分，而且第一次打开反编译器甚至对经验丰富的开发人员来说都可能令人
望而生畏。本文档的范围远远不足以教您如何逆向工程游戏，但它至少可以为您提供一些指
导，让您自己找出问题。

## 入门

从根本上讲，《最终幻想 XIV》正在您的计算机上运行，这意味着它在本地不断运行游戏代
码。这些代码负责与服务器通信、渲染场景、绘制 UI 元素、确定玩家处于什么状态以及各
种其他事情。所有这些都发生在游戏的进程和内存空间中，使用在您的计算机上的
`ffxiv_dx11.exe` 文件中找到的指令（通常是汇编语言）。

然而，这里有一个问题：我们没有《最终幻想 XIV》的源代码。他们提供给我们的最终程序
非常简化，几乎没有有用的信息。为此，社区创建并维护了一个名为
[FFXIVClientStructs](https://github.com/aers/FFXIVClientStructs) 的项目，它提供
了有关游戏内部的一般信息，并提供了一组 C# 绑定，有效地允许插件将游戏用作库。然而
，这份文档是不完整的，插件开发人员不可避免地需要逆向工程游戏本身来发现新事物。这
使我们顺利地转到了下一个话题...

## 如何逆向工程游戏？

正如之前所提到的，编写一份完整的逆向工程游戏的指南是不可能的。逆向工程是一门非常
复杂的学科，需要多年的时间来掌握。有先前使用 C/C++ 经验的开发人员可能会有一点优
势，但最终仍然是一个难题。

在逆向工程中，至少有两种主要的方法可以与程序交互，以了解它们的运作方式：**静态分
析**是指开发人员阅读游戏的反汇编或反编译源代码，通常使用专门设计用于此目的的工具
；而 **动态分析** 则是使用调试器和内存编辑器创建断点，并在内存更改时进行通知。许
多开发人员都会大量使用这两种机制，因为其中一种机制通常会为另一种机制提供上下文。

### 静态分析

静态分析是指阅读程序的反汇编代码，通常使用交互式反汇编器或反编译器。有许多工具可
帮助完成此过程，例如 [Hex-Rays IDA][ida]、[Ghidra][ghidra] 和 [Binary
Ninja][binja]，但还有其他工具。Dalamud 社区的绝大多数人都会使用 IDA 或 Ghidra 进
行工作，并且大多数工具都是为这两个工具之一而构建的。这两个工具之间没有功能上的区
别，因此真正取决于开发人员选择哪个更喜欢。

一旦您安装并使用了反汇编器（您肯定已经阅读了手册并找到了一些在线教程来了解如何导
航它，对吧？），就可以加载 `ffxiv_dx11.exe` 并开始探索了。此时，大多数开发人员将
加载[一些数据文件](https://github.com/aers/FFXIVClientStructs/tree/main/ida)，并
使用它来探索所涉及的程序。

[ida]: https://hex-rays.com/
[ghidra]: https://github.com/NationalSecurityAgency/ghidra
[binja]: https://binary.ninja/

### 动态分析

与静态分析不同，动态分析是指检查代码的实时运行情况。这通常是像 [Cheat
Engine][cheat-engine]、[x64dbg][x64dbg] 和 [ReClass.NET][reclass-net] 这样的工具
发挥作用的地方。开发人员通常会使用这些程序来查找有趣的内存地址或在已知数据结构上
放置断点，以查看游戏代码如何影响内存中的某个位置。

某些工具，例如
[pohky 的 XivReClassPlugin](https://github.com/pohky/XivReClassPlugin)，还将一些
动态分析工具与 ClientStructs 数据库绑定在一起，使开发人员可以更快地访问更多信息
。

[cheat-engine]: https://www.cheatengine.org/
[x64dbg]: https://x64dbg.com/
[reclass-net]: https://github.com/ReClassNET/ReClass.NET

## 函数、偏移和特征

正如之前所提到的，最终幻想 XIV 实际上是一个程序。程序通常会遵循从入口点（第一个
被调用的函数）开始的执行流程，到达其他函数，跨越线程，响应用户输入以及各种其他使
游戏实际可玩的事情。游戏将在特定的用户操作上调用某个函数，或使用函数来获取一些相
关数据或执行某些计算，以在 UI 或类似位置中显示。所有这些都是为了说：函数可能是探
索游戏代码的最关键概念之一。

函数存在于程序的内存空间中，从程序的基地址开始的特定偏移量。这些函数偏移量唯一地
标识了特定的函数，并通常在反编译器和其他工具中表示为
`ffxiv_dx11.exe+4BC200`[^1]，尽管大多数开发人员在相互交流时会将其缩短为
`4BC200`。但是，函数偏移量并不是固定的。游戏的每个版本都会更改所有函数偏移量，这
意味着它们对于直接在插件中使用实际上是无用的。相反，开发人员将使用不同（且更稳定
）的唯一标识符：特征。

_特征_ 是一系列特定的字节（表示为十六进制字符串），可唯一标识函数的开始（称为*直
接特征*）或对特定函数的引用（_间接特征_）。例如，取特征
`E8 ?? ?? ?? ?? 41 88 84 2C`。这个字符串在游戏的二进制文件中只存在一次，并唯一地
标识了一个检查玩家是否完成了特定任务的函数。因为特征是指向二进制文件的一部分，所
以它更加稳定 - 除非 Square Enix 更改了特征所代表的代码，或添加了生成相同特征的新
代码，否则特征将不会失效。特征通常会持续多个主要补丁。特征可以由熟练的开发人员手
动制作，也可以使用类似
[Caraxi 的 SigMaker-x64](https://github.com/Caraxi/SigMaker-x64) 的工具自动生成
。

### 使用游戏函数

开发人员可以使用两种主要方法来使用函数：创建一个钩子来拦截函数，或创建一个委托来
使用该函数。

当开发人员想要拦截、修改、取消或以其他方式对函数调用进行操作时，他们将使用钩子。
例如，一个想要知道用户何时切换状态的插件可能会钩取一个 `UpdateStatus` 函数，并采
取一些自己的行动。同时，一个想要检查玩家是否完成任务的开发人员将创建一个指向
`IsQuestCompleted` 函数的委托，以便他们可以随意调用它。

在这两种情况下，开发人员需要知道他们正在与之交互的函数的参数列表（和返回类型），
尽管静态分析工具将向开发人员公开此信息[^2]。在许多情况下，并非所有参数都是已知的
（通常表示为 `a3` 或类似的内容），或者参数可能是指向特定（并且可能未知！）结构的
指针。

## 关于结构和数据类型

结构只是 C 结构。我们有时将它们移植到 C# 中，并使用布局。指针数学也是一种技巧。
我们经常使用 `intptr/nint`。

[^1]:
    有时，您还会看到 `1404BC200`。这是 `0x140000000` 的 `/BASE` 加上函数的偏移量
    ，其中基地址是
    [FFXIV 使用的编译器](https://learn.microsoft.com/en-us/cpp/build/reference/base-base-address?view=msvc-170)
    的属性。

[^2]:
    静态分析工具将使用
    [x64 调用约定](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention)
    来确定参数的位置。
